/**
 *
 * Process Editor - inubit Workbench Plugin Package
 *
 * (C) 2009, 2010 inubit AG
 * (C) 2014 the authors
 *
 */
package com.inubit.research.gui.plugins;

import com.inubit.research.gui.Workbench;
import java.awt.Component;
import javax.swing.JTable;
import javax.swing.table.TableCellRenderer;
import net.frapu.code.visualization.ProcessEdge;
import net.frapu.code.visualization.ProcessModel;
import net.frapu.code.visualization.ProcessModelListener;
import net.frapu.code.visualization.ProcessModelMetaNode;
import net.frapu.code.visualization.ProcessNode;
import net.frapu.code.visualization.ProcessObject;

/**
 *
 * @author fpu
 */
public class PropertiesPluginDialog extends javax.swing.JDialog implements ProcessModelListener {

    /**
     *
     */
    private static final long serialVersionUID = 4091844063183178291L;
    private Workbench workbench;
    private ProcessObject currentObject = null;
    private ProcessModel currentModel = null;

    /** Creates new form PropertiesPluginDialog */
    public PropertiesPluginDialog(Workbench parent, boolean modal) {
        super(parent, modal);
        this.workbench = parent;
        initComponents();
        propertiesTable.setVisible(false);
        setObject(null,null);
    }

    public void setObject(ProcessModel processModel, ProcessObject obj) {
        if (obj !=null) {
            if (currentModel != null) {
                currentModel.removeListener(this);
            }
            currentModel = processModel;
            processModel.addListener(this);
        }

        currentObject = obj;

        if (obj == null)  {
            obj = new ProcessModelMetaNode(workbench.getSelectedModel());
        }

        if (obj != null) {
            String longName = obj.getProperty(ProcessObject.PROP_CLASS_TYPE);
            propertiesElementLabel.setText("Properties of " + longName.substring(longName.lastIndexOf('.') + 1));

            propertiesTable.removeAll();
            propertiesTable.removeEditor();  
            PropertiesTableModel model = new PropertiesTableModel(obj);
            propertiesTable.setModel(model);
            propertiesTable.setDefaultRenderer(Component.class, model);
            propertiesTable.setDefaultEditor(Component.class, model);

            packRows(propertiesTable, 0);

            propertiesTable.setVisible(true);

            jScrollPane1.setViewportView(propertiesTable);

        } else {
            propertiesElementLabel.setText("No element selected");
            propertiesTable.setVisible(false);
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        propertiesElementLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        propertiesTable = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Properties");

        propertiesElementLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        propertiesElementLabel.setText("No element selected");

        propertiesTable.setModel(new javax.swing.table.DefaultTableModel(
                new Object[][]{
                    {null, null},
                    {null, null},
                    {null, null},
                    {null, null}
                },
                new String[]{
                    "Property", "Value"
                }));
        jScrollPane1.setViewportView(propertiesTable);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 249, Short.MAX_VALUE).addComponent(propertiesElementLabel)).addContainerGap()));
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(propertiesElementLabel).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 357, Short.MAX_VALUE).addContainerGap()));

        pack();
    }// </editor-fold>                        
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel propertiesElementLabel;
    private javax.swing.JTable propertiesTable;
    // End of variables declaration//GEN-END:variables


    /**
     *
     * the following code is taken from
     * http://www.exampledepot.com/egs/javax.swing.table/RowHeight.html
     * 
     */
    // Returns the preferred height of a row.
    // The result is equal to the tallest cell in the row.
    public int getPreferredRowHeight(JTable table, int rowIndex, int margin) {
        // Get the current default height for all rows
        int height = table.getRowHeight();

        // Determine highest cell in the row
        for (int c = 0; c < table.getColumnCount(); c++) {
            TableCellRenderer renderer = table.getCellRenderer(rowIndex, c);
            Component comp = table.prepareRenderer(renderer, rowIndex, c);
            int h = comp.getPreferredSize().height + 2 * margin;
            height = Math.max(height, h);
        }
        return height;
    }

    // The height of each row is set to the preferred height of the
    // tallest cell in that row.
    public void packRows(JTable table, int margin) {
        packRows(table, 0, table.getRowCount(), margin);
    }

    // For each row >= start and < end, the height of a
    // row is set to the preferred height of the tallest cell
    // in that row.
    /**
     * @param start
     * @param end  
     */
    public void packRows(JTable table, int start, int end, int margin) {
        for (int r = 0; r < table.getRowCount(); r++) {
            // Get the preferred height
            int h = getPreferredRowHeight(table, r, margin);

            // Now set the row height using the preferred height
            if (table.getRowHeight(r) != h) {
                table.setRowHeight(r, h);
            }
        }
    }

    @Override
    public void processNodeAdded(ProcessNode newNode) {
        //
    }

    @Override
    public void processNodeRemoved(ProcessNode remNode) {
        //
    }

    @Override
    public void processEdgeAdded(ProcessEdge edge) {
        //
    }

    @Override
    public void processEdgeRemoved(ProcessEdge edge) {
        //
    }

    @Override
    public void processObjectPropertyChange(ProcessObject obj, String name, String oldValue, String newValue) {
        // Repaint properties dialog
        this.repaint();
        // Also repaint editor
        this.workbench.getSelectedProcessEditor().repaint();
    }

}
